<HTML>
<HEAD>
<TITLE>sim4parser.pm</TITLE>
<LINK REV="made" HREF="mailto:bengt@tesuque.stanford.edu">
</HEAD>

<BODY>

<A NAME="__index__"></A>
<!-- INDEX BEGIN -->

<UL>

	<LI><A HREF="#name">NAME</A></LI>
	<LI><A HREF="#synopsis">SYNOPSIS</A></LI>
	<LI><A HREF="#description">DESCRIPTION</A></LI>
	<LI><A HREF="#version">VERSION</A></LI>
	<LI><A HREF="#author">AUTHOR</A></LI>
	<LI><A HREF="#functions">FUNCTIONS</A></LI>
	<UL>

		<LI><A HREF="#new()"><CODE>new()</CODE></A></LI>
		<LI><A HREF="#parse()"><CODE>parse()</CODE></A></LI>
		<LI><A HREF="#findbesthit()"><CODE>findBestHit()</CODE></A></LI>
		<LI><A HREF="#neatlist()"><CODE>neatList()</CODE></A></LI>
		<LI><A HREF="#list()"><CODE>list()</CODE></A></LI>
		<LI><A HREF="#getbestscore()"><CODE>getBestScore()</CODE></A></LI>
		<LI><A HREF="#getsecondbestscore()"><CODE>getSecondBestScore()</CODE></A></LI>
		<LI><A HREF="#getbestindex()"><CODE>getBestIndex()</CODE></A></LI>
		<LI><A HREF="#getsecondbestindex()"><CODE>getSecondBestIndex()</CODE></A></LI>
		<LI><A HREF="#getnumberofhits()"><CODE>getNumberOfHits()</CODE></A></LI>
		<LI><A HREF="#getnumberofexonsinbesthit()"><CODE>getNumberOfExonsInBestHit()</CODE></A></LI>
		<LI><A HREF="#getnumberofexons()"><CODE>getNumberOfExons()</CODE></A></LI>
		<LI><A HREF="#getiscomplement()"><CODE>getIsComplement()</CODE></A></LI>
	</UL>

</UL>
<!-- INDEX END -->

<HR>
<P>
<H1><A NAME="name">NAME</A></H1>
<P><STRONG>sim4parser.pm</STRONG></P>
<P>
<HR>
<H1><A NAME="synopsis">SYNOPSIS</A></H1>
<P><CODE>use sim4parser;</CODE></P>
<P><CODE>$parser = sim4parser -&gt; new(&quot;sampleSim4Report.txt&quot;);</CODE></P>
<P><CODE>$besthit = $parser -&gt; parse();</CODE></P>
<P><CODE>$parser -&gt; list ($besthit);</CODE></P>
<P>
<HR>
<H1><A NAME="description">DESCRIPTION</A></H1>
<P>The sim4parser module provides functionality to parse the output of sim4 report that were generated using the <STRONG>A=0</STRONG> option. It does not parse output generated by any other sim4 option.</P>
<P>The following function (see below) are currently supported:</P>
<P><CODE>new()</CODE></P>
<P><CODE>parse()</CODE></P>
<P><CODE>findBestHit() </CODE></P>
<P><CODE>neatList() </CODE></P>
<P><CODE>list()</CODE></P>
<P><CODE>getBestScore() </CODE></P>
<P><CODE>getSecondBestScore()</CODE></P>
<P><CODE>getBestIndex() </CODE></P>
<P><CODE>getSecondBestIndex()</CODE></P>
<P><CODE>getNumberOfHits() </CODE></P>
<P><CODE>getNumberOfExonsInBestHit() </CODE></P>
<P><CODE>getNumberOfExons() </CODE></P>
<P><CODE>getIsComplement() </CODE></P>
<P>
<HR>
<H1><A NAME="version">VERSION</A></H1>
<P>0.1 (October 18, 2001)</P>
<P>
<HR>
<H1><A NAME="author">AUTHOR</A></H1>
<P>Lukas Mueller (<A HREF="mailto:mueller@acoma.stanford.edu">mueller@acoma.stanford.edu</A>)</P>
<P>
<HR>
<H1><A NAME="functions">FUNCTIONS</A></H1>
<P>
<H2><A NAME="new()"><CODE>new()</CODE></A></H2>
<P>Creates a new parser object. Parameter: filename of the report to parse. 
Returns a handle to a parsing object.</P>
<P><CODE>$parser = sim4parser -&gt; new();</CODE></P>
<P>
<H2><A NAME="parse()"><CODE>parse()</CODE></A></H2>
<P>Parses the parser object generated with new.</P>
<P><CODE>$parser = sim4parser -&gt; new(&quot;testfile&quot;);</CODE></P>
<P><CODE>$besthit = $parser -&gt; parse();</CODE></P>
<P>Takes no parameters, returns the internal index of the best hit.</P>
<P>
<H2><A NAME="findbesthit()"><CODE>findBestHit()</CODE></A></H2>
<P>Returns the best sim4 hit as an index number to the internal datastructure. This number can be used in other function calls. This is determined by looking at the length of the alignment. The longest alignment wins (over all exons). Note that this can be problematic if matches contain == type matches and are not adjacent on the chromosome. This function is called internally by <CODE>parse()</CODE>.</P>
<P>
<H2><A NAME="neatlist()"><CODE>neatList()</CODE></A></H2>
<P>Takes an index as parameter. Prints the results out as a neat list.</P>
<P>
<H2><A NAME="list()"><CODE>list()</CODE></A></H2>
<P><CODE>$parser -&gt; list($i);</CODE></P>
<P>Lists the match with index $i.</P>
<P>
<H2><A NAME="getbestscore()"><CODE>getBestScore()</CODE></A></H2>
<P><CODE>$best = $parser -&gt; getBestScore(); </CODE></P>
<P>Returns the best Score of the best match. The score is the alignment length in the match. The <CODE>parse()</CODE> function has to be called prior to calling this (and any of the following) function(s).</P>
<P>
<H2><A NAME="getsecondbestscore()"><CODE>getSecondBestScore()</CODE></A></H2>
<P>Returns the second best score.</P>
<P>
<H2><A NAME="getbestindex()"><CODE>getBestIndex()</CODE></A></H2>
<P>Returns the internal index of the best hit. This number can then be fed to other functions such as list to output the details of the match.</P>
<P>
<H2><A NAME="getsecondbestindex()"><CODE>getSecondBestIndex()</CODE></A></H2>
<P>Returns the internal index of the second best hit.</P>
<P>
<H2><A NAME="getnumberofhits()"><CODE>getNumberOfHits()</CODE></A></H2>
<P>Returns the number of hits.</P>
<P>
<H2><A NAME="getnumberofexonsinbesthit()"><CODE>getNumberOfExonsInBestHit()</CODE></A></H2>
<P>Returns the number of exons in the best hit.</P>
<P>
<H2><A NAME="getnumberofexons()"><CODE>getNumberOfExons()</CODE></A></H2>
<P>Returns the number of exons of the match at internal index $i:
<CODE>$exons = $parser -&gt; getNumberOfExons($i);</CODE></P>
<P>
<H2><A NAME="getiscomplement()"><CODE>getIsComplement()</CODE></A></H2>
<P>Checks if the match at index $i is on the forward or reverse strand. The function returns 1 if the hit on the complement strand, 0 otherwise.</P>
<P><CODE>if ($parser -&gt; getIsComplement($i)) { doSomething(); }</CODE></P>

</BODY>

</HTML>
