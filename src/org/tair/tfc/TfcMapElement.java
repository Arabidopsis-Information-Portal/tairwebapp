//-----------------------------------------------------------------------------
// Copyright (c) 2010 Carnegie Institution for Science. All rights reserved. 
// $Revision: 1.27 $
// $Date: 2004/07/28 23:16:59 $
//------------------------------------------------------------------------------

package org.tair.tfc;

import java.util.*;
import java.sql.*;

import org.tair.utilities.*;

/**
 * TfcMapElement is an abstract class that encapsulates the data and SQL
 * for retrieving data common to all classes that inherit from MapElement.
 *
 * <p>
 * TfcTairObject superclass defines a constructor that takes a Long primary
 * key as an argument. The superclass implementation of the constructor can
 * and should be used by all sub-classes to populate an object instance that
 * reflects the data referenced by that primary key. Superclass constructor
 * will retrieve a full list of all column names to include in the population
 * SQL statement through the getCombinedColumns method. This method combines
 * all superclass column names with child table specific column names, as
 * defined by the getColumns method, to create a single list of all columns 
 * to be included in the SQL SELECT statement that populates the object 
 * instance. 
 *
 * <P>
 * This class overrides the TfcTairObject implementation of getCombinedColumns
 * to ensure that both MapElement and TairObject columns are combined with 
 * child table specific columns to form the complete list.
 *
 * <p>
 * Each sub-class of TairObject must implement the populate method. This
 * method should retrieve all child table column values from the database
 * result set generated by executing SQL from getPopulationSQL and store
 * these values in member variables. TfcTairObject's constructor will populate
 * superclass data by calling the populateSuperClass method.  This class
 * overrides this method to ensure that MapElement data is stored locally
 * along with TairObject data in the superclass.
 *
 * <p>
 * This division of column names and member variables allows us to keep
 * all TairObject and MapElement data, SQL and methods in the superclasses,
 * while getting all data to populate the object instance through a single 
 * database query.
 * 
 * <p>
 * MapElementType data is stored locally in this class as well, though
 * it is actually stored in the database in the MapElementType lookup
 * table.  This is done since type data is frequently needed, and it's
 * cumbersome to create another class to contain both Tfc objects.  Type
 * ids are translated to literal type values using TfcMapElementType,
 * which will cache data as it retrieves it so that future creations of
 * identical object types will not result in an additional SQL query.
 */

public abstract class TfcMapElement extends TfcTairObject {   

    private Long map_element_id;
    private Long map_element_type_id;
    private String map_element_type;

    /**
     * Empty constructor provided so that sub-classes can provide the 
     * no argument constructor with no problems.
     */

    public TfcMapElement() { 
	super();
    }

    /**
     * Populates an instance of concrete sub-class of TfcMapElement to
     * reflect the data referenced by submitted id.  This constructor
     * will call constructor defined in TfcTairObject superclass that
     * can be used by all sub-classes to handle object population; all
     * details needed for populating a specific type of object, including
     * table columns to include in SELECT, primary key column and database
     * table name to SELECT against are retrieved polymorphically through
     * the implementations of abstract methods defined in superclass
     *
     * @param conn An active connection to the database
     * @param id Primary key value of row to retrieve for population
     * @throws RecordNotFoundException if no row found for submitted id
     * @throws SQLException if a database error occurs
     */

    public TfcMapElement( DBconnection conn, Long id ) 
	throws RecordNotFoundException, SQLException {

	super( conn, id );
    }
	
    /**
     * Populates MapElement data from submitted result set. This method
     * overrides the implementation in TfcTairObject to ensure that
     * MapElement data is populated along with TairObject data. TfcTairObject
     * constructor will call this method to make sure that all superclass
     * data is populated before calling the populate method that must
     * be implemented by all sub-classes to populate child table
     * specific member variables.
     *
     * <p>
     * This method assumes that the first row of the result set has already 
     * been moved to by calling next() on the result set. Method also assumes
     * that map element level columns will be found in the result set.  If 
     * SQL statement is created using the list of column names returned by
     * getCombinedColumns, this should always be true.
     *
     * @param results ResultSet containing MapElement data from a single
     * row in child class's database table.
     * @throws SQLException if a database error occurs
     */

     protected final void populateSuperClass( ResultSet results ) 
	throws SQLException {

	long id = results.getLong( "map_element_id" );

	if ( !results.wasNull() ) {
	    set_map_element_id( new Long( id ) );
	}
	
	// get map element type data and store locally

	TfcMapElementType mapElementType = 
	    new TfcMapElementType( getTableName() );
	set_map_element_type( mapElementType.get_map_element_type() );
	set_map_element_type_id( mapElementType.get_map_element_type_id() );

	// populate TairObject data

	super.populateSuperClass( results );
    }

    /**
     * Retrieves full list of all column names to be included in the SQL
     * statement to populate an object instance.  This method overrides the
     * TfcTairObject implementation to combine MapElement column names along
     * with all TairObject and child table specific columns to make a single 
     * list containing all column names for the SQL query. This method is 
     * called by the getPopulationSQL method in TfcTairObject and relies on 
     * the polymorphic implementations of getColumns method in inheriting
     * classes to define child table specific columns.
     *
     *
     * @return Full list of all column names to be included in SQL statement
     * that populates object instance.
     */

    protected final String[] getCombinedColumns() {
	
	// combine local columns with super class columns

	return TextConverter.combineStringArrays( getTairObjectColumns(),
						  getMapElementColumns(),
						  getColumns() );
	
    }
    
    /**
     * Returns array of column names for MapElement level data. Local
     * implementation of getCombinedColumns method will combine these
     * columns with TairObject columns (as returned by getTairObjectColumns)
     * and all child table columns as defined by the getColumns method
     * implemented in all concrete sub-classes.
     *
     * <p>
     * Including these column names ensures that the implementation of 
     * populateMapElement will succeed since the literal column values used
     * to retrieve data will be guaranteed to exist in the result set.
     *
     * @return String array of column names that conceptually belong at
     * the MapElement level.
     */

    protected final String[] getMapElementColumns() {

	String[] columns = new String[] {
	    "map_element_id"
	};
	
	return columns;
    }
  
    /**
     * Retrieves tair_object_id for submitted map_element_id
     *
     * @param conn An active connection to the database
     * @param map_element_id Map element id to retrieve tair_object_id for
     * @throws SQLException if a database error occurs
     * @return Tair object id for submitted map_element_id, or <code>null</code>
     * if  map element id is not found
     */
    public static Long get_super_id( DBconnection conn, Long map_element_id )
	throws SQLException {

	String query = null;
	Long tairObjectID = null;

	if ( map_element_id != null ) {
	    query =
		"SELECT tair_object_id "+
		"FROM MapElement "+
		"WHERE map_element_id = ?";
	    conn.setQuery( query );
	    conn.setQueryVariable( map_element_id );
	    
	    ResultSet results = conn.getResultSet();

	    if ( results.next() ) {
		tairObjectID = new Long( results.getLong( "tair_object_id" ) );
	    }

	    conn.releaseResources();
	}

	return tairObjectID;
    }

    /**
     * Sets the value of map element id
     *
     * @param id Map element id to set for this object
     */

    public final void set_map_element_id( Long id ) {
	this.map_element_id = id; 
    }

    /**
     * Retrieves map element id for object
     *
     * @return Map element id for object
     */

    public final Long get_map_element_id() { 
	return map_element_id; 
    }

    /**
     * Sets the value of map element type id
     *
     * @param id Map element type id to set for this object
     */

    public final void set_map_element_type_id( Long id ) { 
	this.map_element_type_id = id; 
    }

    /**
     * Retrieves map element type id for object
     *
     * @return Map element type id for object
     */

    public final Long get_map_element_type_id() { 
	return map_element_type_id; 
    }

    /**
     * Sets the value of map element type
     *
     * @param type Map element type to set for this object
     */

    public final void set_map_element_type( String type ) { 
	this.map_element_type = type; 
    }

    /**
     * Retrieves map element type for object
     *
     * @return Map element type for object
     */

    public final String get_map_element_type() { 
	return map_element_type; 
    }

    /**
     * Determines whether map element with submitted id is mapped 
     * onto the AGI map
     *
     * @return <code>true</code> if at least one assignment is found for 
     * map_element_id onto the AGI map; <code>false</code> if no assignments
     * onto AGI map found
     * @throws SQLException if database error occurs
     */

    public static boolean is_agi_map( DBconnection conn, Long map_element_id ) 
	throws SQLException {

	boolean isAGIMap = false;

	if ( map_element_id != null ) {
	    String query = 
		"SELECT ga.assignment_id " +
		"FROM GlobalAssignment ga, Map m " +
		"WHERE ga.map_id = m.map_id " + 
		"AND m.name = 'AGI' " +
		"AND ga.is_obsolete = 'F' " +
		"AND ga.map_element_id = ?";

	    conn.setQuery( query );
	    conn.setQueryVariable( map_element_id );

	    ResultSet results = conn.getResultSet();
	    if ( results.next() ) {
		isAGIMap= true;
	    }

	    conn.releaseResources();
	}

	return isAGIMap;
    }

    /**
     * Utility method to determine whether a link to map viewer can be made for 
     * map element with submitted id and type.  This is used by detail pages 
     * and results pages to determine whether a given map element should show
     * the link or not; the determination is made by searching the element's 
     * assignment data.  This method will return true if:
     * 
     * <ul>
     * <li>Element is assigned to chromosomes 1-5 (i.e. not chloroplast or 
     *  mitochondria [C/M])
     * <li>Submitted element has any asssignments on a non-AGI map
     * <li>Or if  submitted element has assignments on AGI map and map element
     *  type is locus, gene, genetic_marker or assembly_unit
     * </ul>
     *
     * @param conn An active connection to the database
     * @param map_element_id Map element id to retrieve assignment data for
     * @param map_element_type Map element type of object w/submitted 
     *  map_element_id
     * @return <code>true</code> if element's assignments will support a link 
     *         to map viewer, or <code>false</code> if no link to map viewer 
     *         can be made
     * @throws SQLException thrown if a database error occurs
     */

    public static boolean showMapViewerLink( DBconnection conn, 
					     Long map_element_id, 
					     String map_element_type ) 
	throws SQLException { 

	String query = null;
	ResultSet results = null;
	String map = null;
	boolean showLink = false;
	boolean hasAGI = false;
	boolean hasOther = false;

	if ( map_element_id != null && map_element_type != null ) {
	    query =
		"SELECT m.name FROM GlobalAssignment ga, Map m " +
		"WHERE ga.map_id = m.map_id " +
		"AND ga.is_obsolete = 'F' " +
		"AND m.chromosome not IN ( 'C', 'M' ) " +
		"AND ga.map_element_id = ?";
	    conn.setQuery( query );
	    conn.setQueryVariable ( map_element_id );
	    results = conn.getResultSet();

	    while ( results.next() ) {
		map = results.getString( "name" );

		if ( map.equals( "AGI" ) ) {
		    hasAGI = true;
		} 
		else {
		    hasOther = true;
		}

		// If already determined that element has both types of 
		// assignments quit now to save time

		if ( hasAGI && hasOther ) { 
		    break;
		}
	    }

	    conn.releaseResources();
      
	    // Show link if element has non-AGI assignment (except for LYRATA)

	    if ( hasOther && !map.equals( "LYRATA" ) ) {
		showLink = true;
            }

            // If only has AGI assignment, show link according to map 
            // element type

            else if ( hasAGI && 
                      ( map_element_type.equals( "gene" ) ||
                        map_element_type.equals( "locus" ) ||
                        map_element_type.equals( "genetic_marker" ) ||
                        map_element_type.equals( "assembly_unit" ) ) ) {
		showLink = true;
	    }
	}

	return showLink;
    }
        
    /**
     * Retrieves the distinct list of chromosome values from submitted 
     * map_element_id's assignments onto the AGI map.  This is useful for 
     * creating links to seq viewer where each chromosome value passed must
     * be from an AGI map assignment, or seq viewer will not find data to 
     * display.  Elements that need to display links to seq viewer can use
     * this utility method to get a validated list of chromosome values 
     * that can be used for seq viewer.
     *
     * @param conn An active connection to the database
     * @param map_element_id Map element id to retrieve chromosomes for
     * @return List of chromosome values from map_element_id's assignments 
     * onto AGI map, or <code>null</code> if no assignments to AGI map found 
     * for map_element_id
     */
    
    public static String[] getALYChromosomes( DBconnection conn, 
		      Long map_element_id ) 
    throws SQLException {
    	return getChromosomes(conn,map_element_id, "LYRATA");
    	
    }

    public static String[] getAGIChromosomes( DBconnection conn, 
					      Long map_element_id ) 
	throws SQLException {
    	return getChromosomes(conn,map_element_id, "AGI");
    	
    }
    
    public static String[] getChromosomes( DBconnection conn, 
		      Long map_element_id, String mapName ) 
    throws SQLException {

	ArrayList chromoResults = null;
	String[] chromosomes = null;
	String query = null;
	ResultSet results = null;

	if ( map_element_id != null ) {
	    query =
		"SELECT distinct m.chromosome " +
		"FROM GlobalAssignment ga, Map m " +
		"WHERE ga.map_id = m.map_id " +
		"AND ga.is_obsolete = 'F' " +
		"AND m.name = ?" +
		"AND ga.map_element_id = ?";
	    conn.setQuery( query );
	    conn.setQueryVariable(1, mapName);
	    conn.setQueryVariable(2, map_element_id );
	    results = conn.getResultSet();

	    while ( results.next() ) {
		if ( chromoResults == null ) {
		    chromoResults = new ArrayList();
		}

		chromoResults.add( results.getString( "chromosome" ) );
	    }

	    conn.releaseResources();

	    if ( chromoResults != null && !chromoResults.isEmpty() ) {
		chromosomes = new String[ chromoResults.size() ];
		chromosomes = (String[]) chromoResults.toArray( chromosomes );
	    }
	}

	return chromosomes;
    }

    /**
     * Stores MapElement data to the database as either an INSERT or an
     * UPDATE depending on whether map_element_id is NULL or not.  This
     * method should always be called by sub-classes when they store their
     * data.  In particular, when INSERTing, new MapElement and TairObject
     * rows must be created before a child class row can be created, since 
     * both map_element_id and tair_object_id are required in the child table
     * for referential integrity.
     *
     * <p>
     * This method stores to the database without any transaction handling; 
     * transaction handling must be implemented by client code that is storing 
     * child class data.
     *
     * @param conn An active connection to the database; connection must have 
     * UPDATE/INSERT  permissions
     * @throws RecordNotFoundException if no row found with current 
     *  map_element_id
     * @throws SQLException if a database error occurs
     * @throws InvalidActionException thrown if no map_element_type can be 
     * determined for child table
     */

    public void store( DBconnection conn ) 
	throws RecordNotFoundException, InvalidActionException, SQLException {

	// call superclass implementation first to ensure all TairObject
	// data is properly updated before continuing on to MapElement

	super.store( conn );

	if ( get_map_element_id() == null ) {
	    insertMapElement( conn );
	} 
        else {
	    updateMapElement( conn );
	}
    }  

    /**
     * Updates data physically stored in MapElement table.
     *
     * @param conn An active connection to the database with UPDATE
     *  permissions
     * @throws RecordNotFoundException if no row found with current 
     * map_element_id
     * @throws SQLException if a database error occurs.
     */

    private void updateMapElement( DBconnection conn ) 
	throws RecordNotFoundException, SQLException {

	String query =
	    "UPDATE MapElement " +
	    "SET map_element_type_id = ? " + 
	    "WHERE map_element_id = ?";

	conn.setQuery( query );
	conn.setQueryVariable( 1, get_map_element_type_id() );
	conn.setQueryVariable( 2, get_map_element_id() );

	int rowsAffected = conn.executeUpdate();
	conn.releaseResources();

	if ( rowsAffected <= 0 ) { 
	    throw new RecordNotFoundException( "Update action failed: " +
					       "No row found in MapElement " +
					       "for map_element_id " + 
					       get_map_element_id() );
	}
    }

    /**
     * Inserts data physically stored in MapElement table. This
     * method assumes a new row has already been inserted into TairObject
     * and a newly created tair_object_id is available in superclass
     * member variable. Newly created map_element_id will be stored in 
     * local member variable for future reference
     *
     * @param conn An active connection to the database with UPDATE
     *  permissions
     * @throws InvalidActionException if no map element type can be
     * determined for child table
     * @throws SQLException if a database error occurs.
     */

    private void insertMapElement( DBconnection conn )
	throws InvalidActionException, SQLException {

	// if map element type hasn't been specified, try
	// to get value from table name defined in child class
	// before throwing exception -- should never fail to
	// get value, but ya never know....

        if ( get_map_element_type_id() == null ) {
	    try {

		TfcMapElementType type = 
		    new TfcMapElementType( getTableName() );
		set_map_element_type_id( type.get_map_element_type_id() );
		set_map_element_type( type.get_map_element_type() );

	    } catch ( RecordNotFoundException rnfe ) {
		throw new InvalidActionException( "Insert of map element " +
						  "failed: No map element " +
						  "type can be " +
						  "determined for table: " +
						  getTableName() );
	    }
	}

	// insert MapElement data and save new map_element_id

	String query = 
	    "INSERT MapElement (map_element_type_id, tair_object_id) " +
	    "VALUES ( ?, ? ) " + 
	    "SELECT @@IDENTITY AS map_element_id ";

	conn.setQuery( query );
        conn.setQueryVariable( 1, get_map_element_type_id() );
        conn.setQueryVariable( 2, get_tair_object_id() );
	ResultSet results = conn.getResultSet();

	if ( results.next() ) {
	    set_map_element_id( 
		new Long( results.getLong( "map_element_id" ) ) );
	}

	conn.releaseResources();
    }
    
    /**
     * Utility method to create a SQL statement for updating data stored
     * in a child table of TairObject.  UPDATE statement will be created
     * to include all child table specific data as defined by submitted 
     * childValues Map. This method in really just a convenience method
     * to avoid having to explicitly write out UPDATE statements in child
     * classes.
     *
     * <p>
     * UPDATE statements will always be created to use tair_object_id as
     * primary key value in the WHERE clause of the update.
     * 
     * <p>
     * Child table specific column names and values must be submitted in 
     * localValues map, with column name as String key referencing String 
     * value to store for that column.  All values must be properly quoted 
     * and escaped so they can be included in SQL created here 
     * (TextConverter.dbQuote should handle all cases).  
     *
     * @param conn An active connection to the database with UPDATE 
     * permissions
     * @param localValues Map containing child table specific columns names
     * referencing values to store for that column.  Names and values must
     * be stored as <code>String</code>; values must be properly quoted and
     * escaped for inclusion in UPDATE SQL.
     */

    protected String createChildTableUpdate( Map columnValues ) {

	StringBuffer query = new StringBuffer();

	// create initial update statement

	query.append( "UPDATE " + getTableName() + " SET " );

	String column = null;
	String value = null;

	Iterator iter = columnValues.keySet().iterator();
	boolean first = true;

	while ( iter.hasNext() ) {
	    column = (String) iter.next();
	    value = (String) iter.next();

	    if ( !first ) {
		query.append( ", " );
	    }

	    query.append( column + " = " + value );
	}
	
	// always do UPDATEs using tair_object_id as primary key
	// in WHERE clause

	query.append( "WHERE tair_object_id = " + get_tair_object_id() );

	return query.toString();
    }      


    /**
     * Utility method to create a SQL statement for inserting a new row
     * in a child table of MapElement. SQL statement will be created
     * using superclass implementation (see TfcTairObject).  Method
     * is overridden here, however, to ensure that map_element_id is
     * added to Map of values that will be used for creating INSERT
     * statement (since all child tables need map element id for
     * referential integrity.
     *
     * @param conn An active connection to the database; connection must have 
     * INSERT  permissions
     * @param localValues Map containing child table specific columns names
     * referencing values to store for that column.  Names and values must
     * be stored as <code>String</code>; values must be properly quoted and
     * escaped for inclusion in UPDATE SQL.
     */

    protected String createChildTableInsert( Map columnValues, String identityColumn, String sequenceName ) {

	// add entry for map element id to Map, then pass along 
	// to superclass for creating statment

	columnValues.put( "map_element_id",
			  TextConverter.dbQuote( get_map_element_id() ) );

	return super.createChildTableInsert( columnValues, identityColumn, sequenceName );
    }

    /**
     * For unit testing only
     */ 

    public void test() {
	super.test();
	System.out.println( "****** MapElement content test ******" );
	System.out.println( "map_element_id: " + get_map_element_id() );
	System.out.println( "map_element_type_id: " + 
                            get_map_element_type_id() );
	System.out.println( "map_element_type: " + get_map_element_type() );
	System.out.println( "**** MapElement content test end ****" );
    }

}
 
